# Understanding The Problem Domain Is The Hardest Part Of Programming

### What is the hardest thing about writing code?
<ol> <li>Learning a new technology</li> <li>Naming things</li> <li>Testing your code</li> <li>Debugging</li> <li>Fixing Bugs</li> <li>Making software maintainable</li> <ol>

### Why problem domains are hard
<p>Have you ever tried to put together a jigsaw puzzle that didn’t have any picture on it?  How about one like this one, that has a very similar pattern repeated on it and is double-sided? The reason why puzzles like this one are so hard, is because you can’t really see what you are trying to build very clearly.  Normally when you put together a jigsaw puzzle you follow steps that might look something like this:</p>
<ol> <li>Figure out what the major components of the picture are</li> <li>Sort the pieces by color or component</li> <li>Put together all the border pieces</li> <li>Put together each component of the picture from the piles you created</li> </ol>
<p>This all breaks down when you don’t have a picture with clear components that you can identify. The same thing happens when writing code. Writing code is a lot like putting together a jigsaw puzzle. We put together code with the purpose of building components that we have taken out of the “bigger picture” of the problem domain. The big issue is that many problem domains are like a puzzle with a blurry picture or no picture at all. <strong>The real world is a messy place.  Many of the problem domains we face as programmers are difficult to understand and look completely different depending on your viewpoint.</strong> As programmers, we also are often not given complete information about the problem domain, so we don’t even have the information we need to understand it.Just try and read the famous Domain Driven Design book and you’ll quickly see how complicated and difficult problem domains can be.</p>

### Programming is easy if you understand the problem domain
<p>A long time ago, I worked for Hewlett Packard writing software for multi-function printers. Most of the work at the time was basic waterfall development. There wasn’t much Agile happening there—at least at the time I was there. There was however something really interesting about the waterfall approach and the extreme amount of specification that was done before anything was built—it was very easy to write the code for a feature. I remember writing a tab control for the user interface of a printer and having the complete pixel perfect specs handed to me before I began to write any code.  I was also given all the possible use cases and told exactly how it should function and what it should do under just about every circumstance. Guess how easy it was to write the code to produce this tab control?  Super easy. As much as I frown upon this approach for software development today, there is something interesting to think about here. I was essentially given the entire problem domain in the form of a spec that was clear and unambiguous. <strong>I was easily able to learn that problem domain and because of it, I was able to write the code very easily as well.</strong> Perhaps you have had a similar experience, not necessarily working on a waterfall project where you were given the spec, but perhaps on an Agile project where you took the time to clearly understand the problem domain before writing any code. I’ve spent days trying to implement a feature only to finally go back and talk to a product owner and hash out completely how something should work and why it should work in a particular way, only to go back to my desk and crank out the code in a matter of hours. The more and more I write code, the more I learn that understanding the problem is the most critical piece to the equation. 
<strong>It is very difficult to solve a problem before you know the question.  It’s like buzzing in on Jeopardy before you hear the clue and shouting out random questions.</strong></p>

### What can you do about it?
<p>If understanding the problem domain is the hardest part of programming and you want to make programming easier, you can do one of two things:</p>
<ol> <li>Make the problem domain easier</li> <li>Get better at understanding the problem domain</li> </ol>
<p> <strong>You can often make the problem domain easier by cutting out cases and narrowing your focus to a particular part of the problem.</strong> What I mean by this is that it is often beneficial to take a part of the problem and fully understand that part before expanding the problem domain. Games are really good at this.  Look at most games today and you’ll find that you start with a very small problem domain.  The first level is usually a tutorial that has a basic set of things you can do so that you don’t get overwhelmed.  But, as you advance through the levels, you usually find they get harder and introduce new concepts that build gradually on what you know, until you understand a pretty large problem domain. <em>Starcraft is really good at this.</em> The other choice is to become better at understanding problem domains.  As developers, we tend to think that sitting down and talking to customers or business people who know about the problem domain is a waste of time. It is easy to fall into the trap of thinking you understand enough of the problem to get started coding it.  Best to resist the temptation to “not waste anymore time talking” and make sure you understand a problem inside and out before you try and solve it with code.  It is much more expensive and time consuming to do things over than it is to do them right the first time. I learn this lesson the hard way time and time again. </p>